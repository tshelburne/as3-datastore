/* * This file is part of the DataStore package. * * @author (c) Tim Shelburne <tim@dontlookstudios.com> * * For the full copyright and license information, please view the LICENSE * file that was distributed with this source code. */package dls.datastore {		import dls.datastore.IDataStore;	import dls.datastore.domain.IDomainEntity;	import dls.datastore.factories.IEntityFactory;	import dls.datastore.mappers.IEntityMapper;	import dls.datastore.repositories.EntityRepository;	import dls.datastore.repositories.IEntityRepository;	import dls.debugger.Debug;		import flash.utils.describeType;		/*	 * A class to act as an in-memory database for elements built from a JSON configuration.	 */	public class DataStore implements IDataStore {				/*=========================================================*		 * PROPERTIES		 *=========================================================*/				private var _debugOptions:Object = { "source" : "DataStore" };				private var _data:Object;		private var _repos:Vector.<IEntityRepository>;		private var _entityFactory:IEntityFactory;				/*=========================================================*		 * FUNCTIONS		 *=========================================================*/		 		public function DataStore(repos:Vector.<IEntityRepository>, entityFactory:IEntityFactory) {			_repos = repos;			_entityFactory = entityFactory;		}				/**		 * pass in an entity type and a configuration to build an entity		 */		public function buildEntity(entityType:String, entityConfig:Object, buildReferences:Boolean = true):void {			getRepository(entityType).add(_entityFactory.build(entityType, entityConfig));						if (buildReferences) {				rebuildReferences();			}		}				/**		 * pass in an entity type and a list of entity configurations to quickly add multiple entities		 */		public function buildEntities(entityType:String, entityConfigs:Array, buildReferences:Boolean = true):void {			Debug.out("Building " + entityType + " entities...", Debug.ACTIONS, _debugOptions);			for each (var entityConfig:Object in entityConfigs) {				buildEntity(entityType, entityConfig, false);			}			Debug.out("Entities built...", Debug.ACTIONS, _debugOptions);						if (buildReferences) {				rebuildReferences();			}		}				/**		 * build all the entity references		 */		private function rebuildReferences():void {						// loop through all repositories to check 			for each (var repo:IEntityRepository in _repos) {								// check whether this repository requires reference building				if (repo.numEntities > 0 && repo.hasReferences()) {					Debug.out("Adding references...", Debug.ACTIONS, _debugOptions);										// loop through all entities in this repository					for each (var entity:IDomainEntity in repo.findAll()) {												// if the entity isn't hydrated, attempt to hydrate it						if (!entity.hydrated) {														// loop through all available reference properties and attempt to fill them							var referencesBuilt:uint = 0;							for each (var reference:String in repo.metadata.references) {								var entityReference:IDomainEntity = find(reference, entity[reference].id);																if (entityReference != null) {									referencesBuilt++;									entity[reference] = entityReference;									Debug.out("Reference property: " + reference + " " + entity[reference].id, Debug.DETAILS, _debugOptions);								}							}														// check whether all references for this entity were built							if (referencesBuilt == repo.metadata.references.length) {								entity.hydrated = true;								Debug.out("Entity hydrated: " + repo.type + " " + entity.id, Debug.DETAILS, _debugOptions);							}						}					}								Debug.out("References added...", Debug.ACTIONS, _debugOptions);				}			}		}		 		/**		 * return the repository for the given entity type		 */		public function getRepository(type:String):IEntityRepository {			for each (var repo:IEntityRepository in _repos) {				if (repo.canHandle(type)) {					return repo;				}			}						var newRepository:EntityRepository = new EntityRepository(type);			_repos.push(newRepository);			return newRepository;		}		 		/**		 * a convenience function to simplify finding an entity by type and id		 */		public function find(type:String, id:String):IDomainEntity {			return getRepository(type).find(id);		}	}}