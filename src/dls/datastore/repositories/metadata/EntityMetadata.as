/* * This file is part of the DataStore package. * * @author (c) Tim Shelburne <tim@dontlookstudios.com> * * For the full copyright and license information, please view the LICENSE * file that was distributed with this source code. */package dls.datastore.repositories.metadata {		import dls.datastore.domain.IDomainEntity;	import dls.datastore.repositories.metadata.IEntityMetadata;	import dls.datastore.repositories.metadata.ReferenceProperty;	import dls.debugger.Debug;		import flash.utils.describeType;	import flash.utils.getDefinitionByName;		/*	 * A convenience class to ease using describeType for entities stored in	 * the DataStore.	 */	public class EntityMetadata implements IEntityMetadata {				/*=========================================================*		 * PROPERTIES		 *=========================================================*/				private var _klass:String;		private var _properties:Vector.<String> = new <String>[];		private var _references:Vector.<ReferenceProperty> = new <ReferenceProperty>[];		private var _referenceCollections:Vector.<ReferenceProperty> = new <ReferenceProperty>[];		private var _methods:Vector.<String>  	= new <String>[];				public function get klass():String {			return _klass;		}				public function get properties():Vector.<String> {			return _properties;		}				public function get references():Vector.<ReferenceProperty> {			return _references;		}				public function get referenceCollections():Vector.<ReferenceProperty> {			return _referenceCollections;		}				public function get methods():Vector.<String> {			return _methods;		}				/*=========================================================*		 * FUNCTIONS		 *=========================================================*/		public function EntityMetadata(entity:*) {			var instanceDescription:XML = describeType(entity);						_klass = instanceDescription.@name;						var classDescription:XML = describeType(getDefinitionByName(_klass));						for each (var accessor:XML in classDescription.factory.accessor) {				var property:String = accessor.@name;				var type:String = accessor.@type;								// check that the property is strongly typed before using either isEntity or isEntityVector				if (type != "*" && isEntity(type)) { 					_references.push(new ReferenceProperty(property, type));				}				else if (type != "*" && isEntityVector(type)) {					_referenceCollections.push(new ReferenceProperty(property, getVectorType(type)));				}				else {					_properties.push(property);				}			}						for each (var method:XML in classDescription.factory.method) {				_methods.push(method.@name);			}						Debug.out({"Properties":_properties, "References":_references, "Reference Collections":_referenceCollections, "Methods":_methods}, Debug.DEBUG, { "source" : "DataStore (EntityMetadata)", "title":_klass, "separated":true});		}				/**		 * UNFINISHED - checks that an entity matches the metadata for this klass		 */		public function matches(entity:IDomainEntity):Boolean {			return true;		}				/**		 * checks whether the fully-qualified class name represents an IDomainEntity		 */		private function isEntity(className:String):Boolean {			var classDescription:XML = describeType(getDefinitionByName(className));						return classDescription.factory.implementsInterface.@type == "dls.datastore.domain::IDomainEntity";		}				/**		 * checks whether the fully-qualified class name represents a Vector that contains IDomainEntity's		 */		private function isEntityVector(className:String):Boolean {			// check that the class is a Vector			if (className.search("__AS3__.vec::Vector") != -1) {				// check that the Vector contains IDomainEntity's				var entityClassName:String = getVectorType(className);								return isEntity(entityClassName);			}									return false;		}				private function getVectorType(vectorClassName:String):String {			return vectorClassName.split("Vector.<")[1].substr(0, -1);		}			}	}