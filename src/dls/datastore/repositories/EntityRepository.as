/* * This file is part of the DataStore package. * * @author (c) Tim Shelburne <tim@dontlookstudios.com> * * For the full copyright and license information, please view the LICENSE * file that was distributed with this source code. */package dls.datastore.repositories {		import dls.debugger.Debug;		import dls.datastore.domain.IDomainEntity;	import dls.datastore.repositories.IEntityRepository;		/*	 * A class to contain all elements of a given type built in the DataStore.	 */	public class EntityRepository implements IEntityRepository{				/*=========================================================*		 * PROPERTIES		 *=========================================================*/				private var _debugOptions:Object = { "source" : "DataStore (EntityRepository)" };			private var _type:String;		private var _entityList:Vector.<IDomainEntity> = new <IDomainEntity>[];		private var _metadata:EntityMetadata = null;				public function get type():String {			return _type;		}				public function get numEntities():uint {			return _entityList.length;		}				/**		 * returns the metadata for entities represented in this repository		 */		public function get metadata():EntityMetadata {			return _metadata;		}				/*=========================================================*		 * FUNCTIONS		 *=========================================================*/		public function EntityRepository(type:String) {			_type = type;		}				/**		 * checks that this repository can handle the request for a certain entity type		 */		public function canHandle(type:String):Boolean {			return _type == type;		}				/**		 * check whether entities in this repository have reference properties		 */		public function hasReferences():Boolean {			return _metadata.references.length > 0;		}				/**		 * adds an entity to this repository		 */		public function add(entity:IDomainEntity):void {			Debug.out("Entity added: " + _type + " " + entity.id, Debug.DETAILS, _debugOptions);						if (_metadata == null) {				_metadata = new EntityMetadata(entity);			}			_entityList.push(entity);		}				/**		 * removes an entity from this repository		 */		public function remove(entity:IDomainEntity):void {			_entityList.splice(_entityList.indexOf(entity), 1);		}				/**		 * finds an entity in this repository of a given id		 */		public function find(id:String):IDomainEntity {			Debug.out("Finding entity: " + _type + " " + id, Debug.DETAILS, _debugOptions);						for each(var entity:IDomainEntity in _entityList) {				if (entity.id == id) {					return entity;				}			}			return null;		}				/**		 * returns all entities in this repository		 */		public function findAll():Vector.<IDomainEntity> {			return findBy({});		}				/**		 * return all entities in this repository which match the given criteria		 */		public function findBy(criteria:Object):Vector.<IDomainEntity> {			Debug.out("Finding entities: " + _type + " by:", Debug.DETAILS, _debugOptions);			Debug.out(criteria, Debug.DETAILS, {"title":"   - Criteria"});			var results:Vector.<IDomainEntity> = new <IDomainEntity>[];			for each(var entity:IDomainEntity in _entityList) {				if (isMatch(entity, criteria)) {					results.push(entity);				}			}			return results;		}				/**		 * returns the first entity in this repository which matches the given criteria		 */		public function findOneBy(criteria:Object):IDomainEntity {			Debug.out("Finding one entity: " + _type + " by:", Debug.DETAILS, _debugOptions);			Debug.out(criteria, Debug.DETAILS, {"title":"   - Criteria"});			for each(var entity:IDomainEntity in _entityList) {				if (isMatch(entity, criteria)) {					return entity;				}			}			return null;		}				/**		 * checks that an entity is a match against the given criteria		 */		private function isMatch(entity:IDomainEntity, criteria:Object):Boolean {			var match:Boolean = true;			for(var key:String in criteria) {				match = match ? entity[key] == criteria[key] : false;			}			return match;		}	}	}